+ 第2章 创建和销毁对象
    + 第1条：考虑用静态工厂方法代替构造器
    + 第2条：遇到多个构造器参数时要考虑用构建器
    + 第3条：用私有的构造器或者枚举类型强化Singleton属性
    + 第4条：通过私有构造器强化不可实例化的能力
    + 第5条：避免创建不必要的对象
    + 第6条：消除过期的对象引用
    + 第7条：避免使用终结方法
+ 第3章 对于所有对象都通用的方法
    + 第8条：覆盖equals时请遵守通用约定
    + 第9条：覆盖equals时总要覆盖hashCode
    + 第10条：始终要覆盖toString
    + 第11条：谨慎地覆盖clone
    + 第12条：考虑实现Comparable接口
+ 第4章 类和接口
    + 第13条：使类的成员的可访问性最小化
    + 第14条：在公有类中使用访问方法而非公有域
    + 第15条：使可变性最小化
    + 第16条：复合优于继承
    + 第17条：要么为继承而设计，并提供文档说明，要么就禁止继承
    + 第18条：接口优于抽象类
    + 第19条：接口只用于定义类型
    + 第20条：类层次优于标签类
    + 第21条：用函数对象表示策略
    + 第22条：优先考虑静态成员类
+ 第5章 泛型
    + 第23条：请不要在新代码中使用原生态类型
    + 第24条：消除非受检警告
    + 第25条：列表优先于数组
    + 第26条：优先考虑泛型
    + 第27条：优先考虑泛型方法
    + 第28条：利用有限通配符来提升API的灵活性
    + 第29条：优先考虑类型安全的异构容器
+ 第6章 枚举和注解
    + 第30条：用enum代替int常量
    + 第31条：用实例域代替序数
    + 第32条：用EnumSet代替位域
    + 第33条：用EnumMap代替序数索引
    + 第34条：用接口模拟可伸缩的枚举
    + 第37条：用标记接口定义类型
